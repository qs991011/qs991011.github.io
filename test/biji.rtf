{\rtf1\ansi\ansicpg936\cocoartf2580
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset134 PingFangSC-Regular;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
\f3\fnil\fcharset0 .AppleSystemUIFontMonospaced-Regular;\f4\froman\fcharset0 Times-Roman;\f5\fnil\fcharset0 Menlo-Bold;
\f6\fnil\fcharset0 HelveticaNeue;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red27\green31\blue35;\red67\green67\blue67;
\red255\green255\blue255;\red38\green38\blue38;\red242\green242\blue242;\red93\green108\blue121;\red255\green255\blue255;
\red0\green0\blue0;\red100\green56\blue32;\red196\green26\blue22;\red155\green35\blue147;\red28\green0\blue207;
\red11\green79\blue121;\red15\green104\blue160;\red57\green0\blue160;\red28\green70\blue74;\red108\green54\blue169;
\red50\green109\blue116;\red93\green108\blue121;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c14118\c16078\c18431;\cssrgb\c33333\c33333\c33333;
\cssrgb\c100000\c100000\c100000;\cssrgb\c20000\c20000\c20000;\cssrgb\c96078\c96078\c96078;\csgenericrgb\c36526\c42188\c47515;\csgenericrgb\c100000\c100000\c100000;
\csgenericrgb\c0\c0\c0\c85000;\csgenericrgb\c39147\c22031\c12446;\csgenericrgb\c77000\c10200\c8600;\csgenericrgb\c60759\c13753\c57628;\csgenericrgb\c11000\c0\c81000;
\csgenericrgb\c4314\c30980\c47451;\csgenericrgb\c5882\c40784\c62745;\csgenericrgb\c22454\c0\c62803;\csgenericrgb\c10981\c27276\c28869;\csgenericrgb\c42190\c21278\c66379;
\csgenericrgb\c19418\c42935\c45455;\csgenericrgb\c36526\c42188\c47515\c35000;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid201\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid3}
{\list\listtemplateid4\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid301\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid4}
{\list\listtemplateid5\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid401\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid5}
{\list\listtemplateid6\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid501\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid6}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}{\listoverride\listid5\listoverridecount0\ls5}{\listoverride\listid6\listoverridecount0\ls6}}
\paperw11900\paperh16840\margl1440\margr1440\vieww18520\viewh12260\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \'c0\'eb\'c6\'c1\'e4\'d6\'c8\'be
\f1 \
layer
\f0 .mask \'b5\'c4\'cd\'bc\'b2\'e3\
layer.masksToBounds view.clipsToBounds\

\f1 \
\
\pard\pardeftab720\sl320\partightenfactor0

\f2\fs26 \cf2 \expnd0\expndtw0\kerning0
rm -rf ~/Library/Developer/Xcode/DerivedData\

\f0 \'c8\'a1\'cf\'fb\'ce\'c4\'bc\'fe\'b8\'fa\'d7\'d9
\f2 \
git rm -r -n \'97cached 
\f0 \'ce\'c4\'bc\'fe\'c4\'bf\'c2\'bc
\f2  
\f0 //-n \'bc\'d3\'c9\'cf\'d5\'e2\'b8\'f6\'b2\'ce\'ca\'fd\'b2\'bb\'bb\'e1\'b4\'d3git \'b8\'fa\'d7\'d9\'c0\'ef\'c9\'be\'b3\'fd\
\
\'c1\'d9\'bd\'e7\'c7\'f8\'b6\'ce \'b7\'c3\'ce\'ca\'d2\'bb\'b8\'f6\'b9\'b2\'cf\'ed\'d7\'ca\'d4\'b4\'b3\'cc\'d0\'f2\'c6\'ac\'b6\'ce\'a3\'ac\'b9\'b2\'cf\'ed\'d7\'ca\'d4\'b4\'ce\'de\'b7\'a8\'cd\'ac\'ca\'b1\'b1\'bb\'b6\'e0\'b8\'f6\'cf\'df\'b3\'cc\'b7\'c3\'ce\'ca\'b5\'c4\'cc\'d8\'d0\'d4\
\
\'d7\'ee\'bc\'f2\'b5\'a5\'b5\'c4\'b0\'ec\'b7\'a8\'be\'cd\'ca\'c7\'cf\'df\'b3\'cc\'bd\'f8\'c8\'eb\'c1\'d9\'bd\'e7\'c7\'f8\'b6\'ce\'ca\'b1\'a3\'ac\'bd\'fb\'d6\'b9\'b8\'c4\'b1\'e4\'b4\'a6\'c0\'ed\'c6\'f7\'a1\'a3\
\
\pard\pardeftab720\sl394\partightenfactor0

\f3\fs27\fsmilli13600 \cf3 cd /usr/local/src\
curl -OL http://nginx.org/download/nginx-1.21.1.tar.gz\
tar -xvzf nginx-1.21.1.tar.gz && rm nginx-1.21.1.tar.gz\
\pard\pardeftab720\sl320\partightenfactor0

\f0\fs26 \cf2 \
ffmpeg -i input.mp4 -s 160x90 -c:v libx264 -b:v 250k -g 90 -an input_video_160x90_250k.mp4\
\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl720\partightenfactor0
\ls1\ilvl0
\f1\fs40 \cf4 \cb5 ffmpeg -i input.mp4 -s 160x90 -c:v libx264 -b:v 250k -g 90 -an input_video_160x90_250k.mp4\cb1 \
\pard\pardeftab720\sl320\partightenfactor0

\f0\fs26 \cf2 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl720\partightenfactor0
\ls2\ilvl0
\f1\fs40 \cf4 \cb5 ffmpeg -i input.mp4 -s 320x180 -c:v libx264 -b:v 500k -g 90 -an input_video_320x180_500k.mp4\cb1 \
\pard\pardeftab720\sl320\partightenfactor0

\f0\fs26 \cf2 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl720\partightenfactor0
\ls3\ilvl0
\f1\fs40 \cf4 \cb5 ffmpeg -i input.mp4 -s 640x360 -c:v libx264 -b:v 750k -g 90 -an input_video_640x360_750k.mp4\cb1 \
\pard\pardeftab720\sl320\partightenfactor0

\f0\fs26 \cf2 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl720\partightenfactor0
\ls4\ilvl0
\f1\fs40 \cf4 \cb5 ffmpeg -i input.mp4 -s 640x360 -c:v libx264 -b:v 1000k -g 90 -an input_video_640x360_1000k.mp4\cb1 \
\pard\pardeftab720\sl320\partightenfactor0

\f0\fs26 \cf2 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl720\partightenfactor0
\ls5\ilvl0
\f1\fs40 \cf4 \cb5 ffmpeg -i input.mp4 -s 1280x720 -c:v libx264 -b:v 1500k -g 90 -an input_video_1280x720_1500k.mp4\cb1 \
\pard\pardeftab720\sl320\partightenfactor0

\f0\fs26 \cf2 \
\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl720\partightenfactor0
\ls6\ilvl0
\f1\fs40 \cf4 \cb5 ffmpeg -i input.mp4 -c:a aac -b:a 128k -vn input_audio_128k.mp4\cb1 \
\pard\pardeftab720\sl320\partightenfactor0

\f0\fs26 \cf2 \
\
\
\
\pard\pardeftab720\sl320\partightenfactor0

\f2 \cf2 LIBSSH2_INCLUDE_DIRS /usr/local/opt/libssh2/include\
LIBSSH2_LIBRARY_DIRS /usr/local/opt/libssh2/lib\
OPENSSL_ROOT_DIR /usr/local/opt/openssl\
OPENSSL_INCLUDE_DIR /usr/local/opt/openssl/include\
OPENSSL_LIBRARIES /usr/local/opt/openssl/lib\
\
ffmpeg -i ipl.mp4 -vf \cf6 \cb7 "\cf2 \cb1 split=2
\f0 [
\f2 main][tmp]; [tmp] crop=iw:ih/2:0:0, vflip [flip]; [main][flip] overlay=o:H/2\'94 out.mp4\
\
\
\pard\pardeftab720\sl360\qj\partightenfactor0
\cf6 \cb7 ffmpeg -i ipl.mp4 -vf "split [main][tmp]; [tmp] crop=iw:ih/2:0:0, vflip [flip]; [main][flip] overlay=0:H/2" out.mp4\
\

\f0 \'b8\'fc\'d0\'c2Xcode
\f2  command line tools\
\
\pard\pardeftab720\sl340\partightenfactor0

\f4 \cf2 \cb1 sudo rm -rf /Library/Developer/CommandLineTools\
 Xcode-select \'97install\
\
\
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f2\fs24 \cf8 \cb9 \kerning1\expnd0\expndtw0 //\cf10 \
\cf8 //  main.cpp\cf10 \
\cf8 //  sim_ffmpeg_test\cf10 \
\cf8 //\cf10 \
\cf8 //  Created by qiansheng on 2021/6/6.\cf10 \
\cf8 //\cf10 \
\
\
\cf11 #include \cf12 <stdio.h>\cf10 \
\cf11 #include \cf12 <assert.h>\cf10 \
\cf11 #ifdef _WIN32\cf10 \

\f5\b \cf13 extern
\f2\b0 \cf10  \cf12 "C"\cf10 \
\{\
\cf11 #include \cf12 "libavcodec/avcodec.h"\cf10 \
\cf11 #include \cf12 "libavformat/avformat.h"\cf10 \
\cf11 #include \cf12 "libswscale/swscale.h"\cf10 \
\cf11 #include \cf12 "libavutil/imgutils.h"\cf10 \
\
\
\};\
\cf11 #else\cf10 \
\
\cf11 #ifdef __cplusplus\cf10 \

\f5\b \cf13 extern
\f2\b0 \cf10  \cf12 "C"\cf10 \
\{\
\cf11 #endif\cf10 \
\cf11 #include \cf12 "libavcodec/avcodec.h"\cf10 \
\cf11 #include \cf12 "libavformat/avformat.h"\cf10 \
\cf11 #include \cf12 "libswscale/swscale.h"\cf10 \
\cf11 #include \cf12 "libavutil/imgutils.h"\cf10 \
\cf11 #include \cf12 "SDL2/SDL.h"\cf10 \
\cf11 #include \cf12 "libavfilter/avfilter.h"\cf10 \
\cf11 #include \cf12 "libavutil/time.h"\cf10 \
\cf11 #include \cf12 "libswresample/swresample.h"\cf10 \
\cf11 #ifdef __cplusplus\cf10 \
\};\
\cf11 #endif\cf10 \
\cf11 #endif\cf10 \
\
\cf11 #define SDL_AUDIO_BUFFER_SIZE \cf14 1024\cf10 \
\cf11 #define MAX_AUDIO_FRAME_SIZE \cf14 19200\cf10 \
\
\cf11 #define MAX_AUDIOQ_SIZE (\cf14 5\cf11  * \cf14 16\cf11  * \cf14 1024\cf11 )\cf10 \
\cf11 #define MAX_VIDEOQ_SIZE (\cf14 5\cf11  * \cf14 256\cf11  * \cf14 1024\cf11 )\cf10 \
\
\cf11 #define AV_SYNC_THRESHOLD \cf14 0.01\cf10 \
\cf11 #define AV_NOSYNC_THRESHOLD \cf14 10.0\cf10 \
\
\cf11 #define FF_REFRESH_EVENT (SDL_USEREVENT)\cf10 \
\cf11 #define FF_QUIT_EVENT (SDL_USEREVENT + \cf14 1\cf11 )\cf10 \
\
\cf11 #define VIDEO_PICTURE_QUEUE_SIZE \cf14 1\cf10 \
\
\
\cf8 // 
\f0 \'b6\'c1\'c8\'a1\'ca\'e4\'c8\'eb\'ce\'c4\'bc\'fe\'d0\'ad\'d2\'e9\'b5\'c4\'ca\'b1\'ba\'f2\'ca\'b9\'d3\'c3
\f2   ,
\f0 \'c0\'b4\'d7\'d4
\f2 ffmpeg
\f0 \'d4\'b4\'c2\'eb
\f2 \cf10 \

\f5\b \cf13 typedef
\f2\b0 \cf10  
\f5\b \cf13 struct
\f2\b0 \cf10  \cf15 URLContext\cf10 \{\
    
\f5\b \cf13 const
\f2\b0 \cf10  \cf16 AVClass\cf10  *\cf16 av_class\cf10 ;\
    
\f5\b \cf13 struct
\f2\b0 \cf10  \cf15 URLProtocol\cf10  *\cf16 prot\cf10 ;\
    
\f5\b \cf13 int
\f2\b0 \cf10  \cf16 flags\cf10 ;\
    
\f5\b \cf13 int
\f2\b0 \cf10  \cf16 is_streamed\cf10 ;\
    
\f5\b \cf13 int
\f2\b0 \cf10  \cf16 max_packet_size\cf10 ;\
    
\f5\b \cf13 int
\f2\b0 \cf10  *\cf16 priv_data\cf10 ;\
    
\f5\b \cf13 char
\f2\b0 \cf10  *\cf16 filename\cf10 ;\
    
\f5\b \cf13 int
\f2\b0 \cf10  \cf16 is_connected\cf10 ;\
    \cf16 AVIOInterruptCB\cf10  \cf16 interrupt_callback\cf10 ;\
\} \cf15 URLContext\cf10 ;\
\

\f5\b \cf13 typedef
\f2\b0 \cf10  
\f5\b \cf13 struct
\f2\b0 \cf10  \cf15 URLProtocol\cf10  \{\
    
\f5\b \cf13 const
\f2\b0 \cf10  
\f5\b \cf13 char
\f2\b0 \cf10  *\cf16 name\cf10 ;\
\}\cf15 URLProtocol\cf10 ;\
\

\f5\b \cf13 typedef
\f2\b0 \cf10  
\f5\b \cf13 struct
\f2\b0 \cf10  \cf15 PacketQueue\cf10 \{\
    \cf16 AVPacketList\cf10  *\cf16 first_pkt\cf10 , *\cf16 last_pkt\cf10 ;\
    
\f5\b \cf13 int
\f2\b0 \cf10  \cf16 nb_packets\cf10 ;\
    
\f5\b \cf13 int
\f2\b0 \cf10  \cf16 size\cf10 ;\
    \cf16 SDL_mutex\cf10  *\cf16 mutex\cf10 ;\
    \cf16 SDL_cond\cf10  *\cf16 cond\cf10 ;\
\}\cf15 PacketQueue\cf10 ;\
\
\cf11 #define SUBPICTURE_QUEUE_SIZE \cf14 4\cf10 \
\

\f5\b \cf13 typedef
\f2\b0 \cf10  
\f5\b \cf13 struct
\f2\b0 \cf10  \cf15 VideoPicture\cf10 \{\
    \cf16 AVFrame\cf10  *\cf16 frame\cf10 ;\
    
\f5\b \cf13 int
\f2\b0 \cf10  \cf16 width\cf10 , \cf16 height\cf10 ;\
    
\f5\b \cf13 double
\f2\b0 \cf10  \cf16 pts\cf10 ;\
\}\cf15 VideoPicture\cf10 ;\
\

\f5\b \cf13 typedef
\f2\b0 \cf10  
\f5\b \cf13 struct
\f2\b0 \cf10  \cf15 VideoState\cf10  \{\
    \
    
\f5\b \cf13 char
\f2\b0 \cf10  \cf16 filename\cf10  [\cf14 1024\cf10 ];\
    \cf16 AVFormatContext\cf10  *\cf16 pFormatCtx\cf10 ;\
    
\f5\b \cf13 int
\f2\b0 \cf10  \cf16 videoStream\cf10 , \cf16 audioStream\cf10 ;\
    \
    
\f5\b \cf13 double
\f2\b0 \cf10  \cf16 audio_clock\cf10 ;\
    
\f5\b \cf13 double
\f2\b0 \cf10  \cf16 frame_timer\cf10 ;\
    
\f5\b \cf13 double
\f2\b0 \cf10  \cf16 frame_last_pts\cf10 ;\
    
\f5\b \cf13 double
\f2\b0 \cf10  \cf16 frame_last_delay\cf10 ;\
    \
    
\f5\b \cf13 double
\f2\b0 \cf10  \cf16 video_clock\cf10 ;\
    
\f5\b \cf13 double
\f2\b0 \cf10  \cf16 video_current_pts\cf10 ;\
    \cf16 int64_t\cf10  \cf16 video_current_pts_time\cf10 ;\
    \
    \cf8 //audio\cf10 \
    \cf16 AVStream\cf10  *\cf16 audio_st\cf10 ;\
    \cf16 AVCodecContext\cf10  *\cf16 audio_ctx\cf10 ;\
    \cf16 PacketQueue\cf10  \cf16 audioq\cf10 ;\
    \cf17 uint8_t\cf10  \cf16 audio_buf\cf10 [(\cf11 MAX_AUDIO_FRAME_SIZE\cf10  * \cf14 3\cf10 )/\cf14 2\cf10 ];\
    
\f5\b \cf13 unsigned
\f2\b0 \cf10  
\f5\b \cf13 int
\f2\b0 \cf10  \cf16 audio_buf_size\cf10 ;\
    
\f5\b \cf13 unsigned
\f2\b0 \cf10  
\f5\b \cf13 int
\f2\b0 \cf10  \cf16 audio_buf_index\cf10 ;\
    \cf18 AVFrame\cf10  \cf16 audio_frame\cf10 ;\
    \
    \cf18 AVPacket\cf10  \cf16 audio_pkt\cf10 ;\
    \cf17 uint8_t\cf10  *\cf16 audio_pkt_data\cf10 ;\
    
\f5\b \cf13 int
\f2\b0 \cf10  \cf16 audio_pkt_size\cf10 ;\
    
\f5\b \cf13 int
\f2\b0 \cf10  \cf16 audio_hw_buf_size\cf10 ;\
    
\f5\b \cf13 struct
\f2\b0 \cf10  \cf18 SwrContext\cf10  *\cf16 audio_swr_ctx\cf10 ;\
    \
    \cf8 //video\cf10 \
    \cf18 AVStream\cf10  *\cf16 video_st\cf10 ;\
    \cf18 AVCodecContext\cf10  *\cf16 video_ctx\cf10 ;\
    \cf18 PacketQueue\cf10  \cf16 videoq\cf10 ;\
    \
    \cf18 VideoPicture\cf10  \cf16 pictq\cf10 [\cf11 VIDEO_PICTURE_QUEUE_SIZE\cf10 ];\
    
\f5\b \cf13 int
\f2\b0 \cf10  \cf16 pictq_size\cf10 , \cf16 pictq_rindex\cf10 , \cf16 pictq_windex\cf10 ;\
    \cf16 SDL_mutex\cf10  *\cf16 pictq_mutex\cf10 ;\
    \cf16 SDL_cond\cf10  *\cf16 pictq_cond\cf10 ;\
    \
    \cf16 SDL_Thread\cf10  *\cf16 parse_tid\cf10 ;\
    \cf16 SDL_Thread\cf10  *\cf16 video_tid\cf10 ;\
    \
    
\f5\b \cf13 int
\f2\b0 \cf10  \cf16 quit\cf10 ;\
\}\cf15 VideoState\cf10 ;\
\
\cf18 SDL_mutex\cf10  *text_mutex;\
\cf18 SDL_Window\cf10  *win = 
\f5\b \cf13 NULL
\f2\b0 \cf10 ;\
\cf18 SDL_Renderer\cf10  *renderer;\
\cf18 SDL_Texture\cf10  *texture;\
\

\f5\b \cf13 static
\f2\b0 \cf10  
\f5\b \cf13 int
\f2\b0 \cf10  screen_left = \cf11 SDL_WINDOWPOS_CENTERED\cf10 ;\

\f5\b \cf13 static
\f2\b0 \cf10  
\f5\b \cf13 int
\f2\b0 \cf10  screen_top = \cf11 SDL_WINDOWPOS_CENTERED\cf10 ;\

\f5\b \cf13 static
\f2\b0 \cf10  
\f5\b \cf13 int
\f2\b0 \cf10  screen_width = \cf14 0\cf10 ;\

\f5\b \cf13 static
\f2\b0 \cf10  
\f5\b \cf13 int
\f2\b0 \cf10  screen_height = \cf14 0\cf10 ;\

\f5\b \cf13 static
\f2\b0 \cf10  
\f5\b \cf13 int
\f2\b0 \cf10  resize = \cf14 1\cf10 ;\
\
\cf18 VideoState\cf10  *global_video_state;\
\

\f5\b \cf13 void
\f2\b0 \cf10  \cf16 packet_queue_init\cf10 (\cf18 PacketQueue\cf10  *q) \{\
    \cf19 memset\cf10 (q, \cf14 0\cf10 , 
\f5\b \cf13 sizeof
\f2\b0 \cf10 (\cf18 PacketQueue\cf10 ));\
    q->\cf20 mutex\cf10  = \cf20 SDL_CreateMutex\cf10 ();\
    q->\cf20 cond\cf10  = \cf20 SDL_CreateCond\cf10 ();\
\}\
\

\f5\b \cf13 int
\f2\b0 \cf10  \cf16 packet_queue_put\cf10 (\cf18 PacketQueue\cf10  *q, \cf18 AVPacket\cf10  *pkt) \{\
    \cf18 AVPacketList\cf10  *pktl;\
    
\f5\b \cf13 if
\f2\b0 \cf10  (\cf20 av_packet_make_refcounted\cf10 (pkt) < \cf14 0\cf10 ) \{\
        
\f5\b \cf13 return
\f2\b0 \cf10  -\cf14 1\cf10 ;\
    \}\
    \
    pktl = (\cf18 AVPacketList\cf10  *)\cf20 av_malloc\cf10 (
\f5\b \cf13 sizeof
\f2\b0 \cf10 (\cf18 AVPacketList\cf10 ));\
    
\f5\b \cf13 if
\f2\b0 \cf10  (!pktl)\
        
\f5\b \cf13 return
\f2\b0 \cf10  -\cf14 1\cf10 ;\
    pktl->\cf20 pkt\cf10  = *pkt;\
    pktl->\cf20 next\cf10  = 
\f5\b \cf13 NULL
\f2\b0 \cf10 ;\
    \
    \cf20 SDL_LockMutex\cf10 (q->\cf20 mutex\cf10 );\
    \
    
\f5\b \cf13 if
\f2\b0 \cf10  (!q->\cf20 last_pkt\cf10 ) q->\cf20 first_pkt\cf10  = pktl;\
    
\f5\b \cf13 else
\f2\b0 \cf10  q->\cf20 last_pkt\cf10 ->\cf20 next\cf10  = pktl;\
    q->\cf20 last_pkt\cf10  = pktl;\
    q->\cf20 nb_packets\cf10 ++;\
    q->\cf20 size\cf10  += pktl->\cf20 pkt\cf10 .\cf20 size\cf10 ;\
    \cf20 SDL_CondSignal\cf10 (q->\cf20 cond\cf10 );\
    \
    \cf20 SDL_UnlockMutex\cf10 (q->\cf20 mutex\cf10 );\
    
\f5\b \cf13 return
\f2\b0 \cf10  \cf14 0\cf10 ;\
\}\
\

\f5\b \cf13 int
\f2\b0 \cf10  \cf16 packet_queue_get\cf10 (\cf18 PacketQueue\cf10  *q, \cf18 AVPacket\cf10  *pkt, 
\f5\b \cf13 int
\f2\b0 \cf10  block) \{\
    \cf18 AVPacketList\cf10  *pktl;\
    
\f5\b \cf13 int
\f2\b0 \cf10  ret;\
    \cf20 SDL_LockMutex\cf10 (q->\cf20 mutex\cf10 );\
    
\f5\b \cf13 for
\f2\b0 \cf10 (;;) \{\
        
\f5\b \cf13 if
\f2\b0 \cf10  (\cf20 global_video_state\cf10 ->\cf20 quit\cf10 ) \{\
            ret = -\cf14 1\cf10 ;\
            
\f5\b \cf13 break
\f2\b0 \cf10 ;\
        \}\
        \
        pktl = q->\cf20 first_pkt\cf10 ;\
        
\f5\b \cf13 if
\f2\b0 \cf10  (pktl) \{\
            q->\cf20 first_pkt\cf10  = pktl->\cf20 next\cf10 ;\
            
\f5\b \cf13 if
\f2\b0 \cf10 (!q->\cf20 first_pkt\cf10 ) q->\cf20 last_pkt\cf10  = 
\f5\b \cf13 NULL
\f2\b0 \cf10 ;\
            q->\cf20 nb_packets\cf10 --;\
            q->\cf20 size\cf10  -= pktl->\cf20 pkt\cf10 .\cf20 size\cf10 ;\
            *pkt = pktl->\cf20 pkt\cf10 ;\
            ret = \cf14 1\cf10 ;\
            
\f5\b \cf13 break
\f2\b0 \cf10 ;;\
        \}
\f5\b \cf13 else
\f2\b0 \cf10  
\f5\b \cf13 if
\f2\b0 \cf10 (!block) \{\
            ret = \cf14 0\cf10 ;\
            
\f5\b \cf13 break
\f2\b0 \cf10 ;;\
        \}
\f5\b \cf13 else
\f2\b0 \cf10  \{\
            \cf20 SDL_CondWait\cf10 (q->\cf20 cond\cf10 , q->\cf20 mutex\cf10 );\
        \}\
    \}\
    \cf20 SDL_UnlockMutex\cf10 (q->\cf20 mutex\cf10 );\
    
\f5\b \cf13 return
\f2\b0 \cf10  ret;\
\}\
\

\f5\b \cf13 double
\f2\b0 \cf10  \cf16 get_audio_clock\cf10 (\cf18 VideoState\cf10  *is) \{\
    
\f5\b \cf13 double
\f2\b0 \cf10  pts;\
    
\f5\b \cf13 int
\f2\b0 \cf10  hw_buf_size, byte_per_sec, n;\
    pts = is->\cf20 audio_clock\cf10 ;\
    \cf8 //
\f0 \'d2\'f4\'c6\'b5\'bb\'ba\'b3\'e5\'c7\'f8\'bb\'b9\'d3\'d0\'c3\'bb\'d3\'d0\'b2\'a5\'b7\'c5\'b5\'c4\'ca\'fd\'be\'dd
\f2 \cf10 \
    hw_buf_size = is->\cf20 audio_buf_size\cf10  - is->\cf20 audio_buf_index\cf10 ;\
    \cf8 // 
\f0 \'c3\'bf\'c3\'eb\'d6\'d3\'d2\'f4\'c6\'b5\'b2\'a5\'b7\'c5\'b5\'c4\'d7\'d6\'bd\'da\'ca\'fd
\f2 \cf10 \
    byte_per_sec = \cf14 0\cf10 ;\
    n = is->\cf20 audio_ctx\cf10 ->\cf20 channels\cf10  * \cf14 2\cf10 ;\
    
\f5\b \cf13 if
\f2\b0 \cf10 (is->\cf20 audio_st\cf10 )\
        byte_per_sec = is->\cf20 audio_ctx\cf10 ->\cf20 sample_rate\cf10  * n;\
    
\f5\b \cf13 if
\f2\b0 \cf10 (byte_per_sec)\
        pts -= (
\f5\b \cf13 double
\f2\b0 \cf10 ) hw_buf_size / byte_per_sec;\
    \
    
\f5\b \cf13 return
\f2\b0 \cf10  pts;\
\}\
\
\cf21 ///
\f6 \cf8 / 
\f0 \'d2\'f4\'c6\'b5\'d6\'a1\'bd\'e2\'c2\'eb
\f2 \cf10 \

\f5\b \cf13 int
\f2\b0 \cf10  \cf16 audio_decode_frame\cf10 (\cf18 VideoState\cf10  *is, \cf17 uint8_t\cf10  *audio_buf, 
\f5\b \cf13 int
\f2\b0 \cf10  buf_size, 
\f5\b \cf13 double
\f2\b0 \cf10  *pts_ptr) \{\
\
    
\f5\b \cf13 int
\f2\b0 \cf10  len1, data_size = \cf14 0\cf10 ;\
    \cf18 AVPacket\cf10  *pkt = &is->\cf20 audio_pkt\cf10 ;\
    
\f5\b \cf13 double
\f2\b0 \cf10  pts;\
    
\f5\b \cf13 int
\f2\b0 \cf10  n;\
\
\
    
\f5\b \cf13 for
\f2\b0 \cf10  (;;) \{\
        
\f5\b \cf13 while
\f2\b0 \cf10  (is->\cf20 audio_pkt_size\cf10  > \cf14 0\cf10 ) \{\
            \cf20 avcodec_send_packet\cf10 (is->\cf20 audio_ctx\cf10 , pkt);\
            
\f5\b \cf13 while
\f2\b0 \cf10  (\cf20 avcodec_receive_frame\cf10 (is->\cf20 audio_ctx\cf10 , &is->\cf20 audio_frame\cf10 ) == \cf14 0\cf10 ) \{\
                len1 = is->\cf20 audio_frame\cf10 .\cf20 pkt_size\cf10 ;\
\
                
\f5\b \cf13 if
\f2\b0 \cf10  (len1 < \cf14 0\cf10 ) \{\
                    \cf8 /* if error, skip frame */\cf10 \
                    is->\cf20 audio_pkt_size\cf10  = \cf14 0\cf10 ;\
                    
\f5\b \cf13 break
\f2\b0 \cf10 ;\
                \}\
\
                data_size = \cf14 2\cf10  * is->\cf20 audio_frame\cf10 .\cf20 nb_samples\cf10  * \cf14 2\cf10 ;\
                \cf11 assert\cf10 (data_size <= buf_size);\
                \
                \cf20 swr_convert\cf10 (is->\cf20 audio_swr_ctx\cf10 ,\
                            &audio_buf,\
                            \cf11 MAX_AUDIO_FRAME_SIZE\cf10  * \cf14 3\cf10  / \cf14 2\cf10 ,\
                            (
\f5\b \cf13 const
\f2\b0 \cf10  \cf17 uint8_t\cf10  **) is->\cf20 audio_frame\cf10 .\cf20 data\cf10 ,\
                            is->\cf20 audio_frame\cf10 .\cf20 nb_samples\cf10 );\
\
            \}\
            is->\cf20 audio_pkt_data\cf10  += len1;\
            is->\cf20 audio_pkt_size\cf10  -= len1;\
            
\f5\b \cf13 if
\f2\b0 \cf10  (data_size <= \cf14 0\cf10 ) \{\
                \cf8 /* No data yet, get more frames */\cf10 \
                
\f5\b \cf13 continue
\f2\b0 \cf10 ;\
            \}\
            pts = is->\cf20 audio_clock\cf10 ;\
            *pts_ptr = pts;\
            n = \cf14 2\cf10  * is->\cf20 audio_ctx\cf10 ->\cf20 channels\cf10 ;\
            is->\cf20 audio_clock\cf10  += (
\f5\b \cf13 double
\f2\b0 \cf10 ) data_size /\
                               (
\f5\b \cf13 double
\f2\b0 \cf10 ) (n * is->\cf20 audio_ctx\cf10 ->\cf20 sample_rate\cf10 );\
            \cf8 /* We have data, return it and come back for more later */\cf10 \
            
\f5\b \cf13 return
\f2\b0 \cf10  data_size;\
        \}\
        
\f5\b \cf13 if
\f2\b0 \cf10  (pkt->\cf20 data\cf10 )\
            \cf20 av_packet_unref\cf10 (pkt);\
\
        
\f5\b \cf13 if
\f2\b0 \cf10  (is->\cf20 quit\cf10 ) \{\
            
\f5\b \cf13 return
\f2\b0 \cf10  -\cf14 1\cf10 ;\
        \}\
        \cf8 /* next packet */\cf10 \
        
\f5\b \cf13 if
\f2\b0 \cf10  (\cf20 packet_queue_get\cf10 (&is->\cf20 audioq\cf10 , pkt, \cf14 1\cf10 ) < \cf14 0\cf10 ) \{\
            
\f5\b \cf13 return
\f2\b0 \cf10  -\cf14 1\cf10 ;\
        \}\
        is->\cf20 audio_pkt_data\cf10  = pkt->\cf20 data\cf10 ;\
        is->\cf20 audio_pkt_size\cf10  = pkt->\cf20 size\cf10 ;\
        \cf8 /* if update, update the audio clock w/pts */\cf10 \
        
\f5\b \cf13 if
\f2\b0 \cf10  (pkt->\cf20 pts\cf10  != \cf11 AV_NOPTS_VALUE\cf10 ) \{\
            is->\cf20 audio_clock\cf10  = \cf20 av_q2d\cf10 (is->\cf20 audio_st\cf10 ->\cf20 time_base\cf10 ) * pkt->\cf20 pts\cf10 ;\
        \}\
    \}\
\}\
\
\cf21 ///
\f6 \cf8 / 
\f0 \'d2\'f4\'c6\'b5\'c9\'e8\'b1\'b8\'bb\'d8\'b5\'f7
\f2 \cf10 \

\f5\b \cf13 void
\f2\b0 \cf10  \cf16 audio_callback\cf10 (
\f5\b \cf13 void
\f2\b0 \cf10  *userdata, \cf18 Uint8\cf10  *stream, 
\f5\b \cf13 int
\f2\b0 \cf10  len) \{\
\
    \cf18 VideoState\cf10  *is = (\cf18 VideoState\cf10  *) userdata;\
    
\f5\b \cf13 int
\f2\b0 \cf10  len1, audio_size;\
    
\f5\b \cf13 double
\f2\b0 \cf10  pts;\
\
    \cf20 SDL_memset\cf10 (stream, \cf14 0\cf10 , len);\
\
    
\f5\b \cf13 while
\f2\b0 \cf10  (len > \cf14 0\cf10 ) \{\
        
\f5\b \cf13 if
\f2\b0 \cf10  (is->\cf20 audio_buf_index\cf10  >= is->\cf20 audio_buf_size\cf10 ) \{\
            \cf8 // 
\f0 \'d2\'f4\'c6\'b5\'bd\'e2\'c2\'eb
\f2 \cf10 \
            audio_size = \cf20 audio_decode_frame\cf10 (is, is->\cf20 audio_buf\cf10 , 
\f5\b \cf13 sizeof
\f2\b0 \cf10 (is->\cf20 audio_buf\cf10 ), &pts);\
            
\f5\b \cf13 if
\f2\b0 \cf10  (audio_size < \cf14 0\cf10 ) \{\
                \cf8 // 
\f0 \'d2\'f4\'c6\'b5\'bd\'e2\'c2\'eb\'b4\'ed\'ce\'f3\'a3\'ac\'b2\'a5\'b7\'c5\'be\'b2\'d2\'f4
\f2 \cf10 \
                is->\cf20 audio_buf_size\cf10  = \cf14 1024\cf10  * \cf14 2\cf10  * \cf14 2\cf10 ;\
                \cf19 memset\cf10 (is->\cf20 audio_buf\cf10 , \cf14 0\cf10 , is->\cf20 audio_buf_size\cf10 );\
            \} 
\f5\b \cf13 else
\f2\b0 \cf10  \{\
                is->\cf20 audio_buf_size\cf10  = audio_size;\
            \}\
            is->\cf20 audio_buf_index\cf10  = \cf14 0\cf10 ;\
        \}\
        len1 = is->\cf20 audio_buf_size\cf10  - is->\cf20 audio_buf_index\cf10 ;\
        
\f5\b \cf13 if
\f2\b0 \cf10  (len1 > len)\
            len1 = len;\
        \cf20 SDL_MixAudio\cf10 (stream, (\cf17 uint8_t\cf10  *) is->\cf20 audio_buf\cf10  + is->\cf20 audio_buf_index\cf10 , len1, \cf11 SDL_MIX_MAXVOLUME\cf10 );\
        len -= len1;\
        stream += len1;\
        is->\cf20 audio_buf_index\cf10  += len1;\
    \}\
\}\
\
\cf21 ///
\f6 \cf8 / 
\f0 \'b6\'a8\'ca\'b1\'c6\'f7\'bb\'d8\'b5\'f7\'ba\'af\'ca\'fd\'a3\'ac\'b7\'a2\'cb\'cd
\f6 FF_REFRESH_EVENT
\f0 \'ca\'c2\'bc\'fe\'a3\'ac\'b8\'fc\'d0\'c2\'cf\'d4\'ca\'be\'ca\'d3\'c6\'b5\'d6\'a1
\f2 \cf10 \

\f5\b \cf13 static
\f2\b0 \cf10  \cf18 Uint32\cf10  \cf16 sdl_refresh_timer_cb\cf10 (\cf18 Uint32\cf10  interval, 
\f5\b \cf13 void
\f2\b0 \cf10  *opaque) \{\
    \cf18 SDL_Event\cf10  event;\
    event.\cf20 type\cf10  = \cf11 FF_REFRESH_EVENT\cf10 ;\
    event.\cf20 user\cf10 .\cf20 data1\cf10  = opaque;\
    \cf20 SDL_PushEvent\cf10 (&event);\
    
\f5\b \cf13 return
\f2\b0 \cf10  \cf14 0\cf10 ;\
\}\
\
\cf21 ///
\f6 \cf8 / 
\f0 \'c9\'e8\'d6\'c3\'b6\'a8\'ca\'b1\'c6\'f7
\f2 \cf10 \

\f5\b \cf13 static
\f2\b0 \cf10  
\f5\b \cf13 void
\f2\b0 \cf10  \cf16 schedule_refresh\cf10 (\cf18 VideoState\cf10  *is, 
\f5\b \cf13 int
\f2\b0 \cf10  delay) \{\
    \cf20 SDL_AddTimer\cf10 (delay, \cf20 sdl_refresh_timer_cb\cf10 , is);\
\}\
\
\cf21 ///
\f6 \cf8 / 
\f0 \'ca\'d3\'c6\'b5\'b2\'a5\'b7\'c5
\f2 \cf10 \

\f5\b \cf13 void
\f2\b0 \cf10  \cf16 video_display\cf10 (\cf18 VideoState\cf10  *is) \{\
\
    \cf18 SDL_Rect\cf10  rect;\
    \cf18 VideoPicture\cf10  *vp;\
\
    
\f5\b \cf13 if
\f2\b0 \cf10  (\cf20 screen_width\cf10  && \cf20 resize\cf10 ) \{\
        \cf20 SDL_SetWindowSize\cf10 (\cf20 win\cf10 , \cf20 screen_width\cf10 , \cf20 screen_height\cf10 );\
        \cf20 SDL_SetWindowPosition\cf10 (\cf20 win\cf10 , \cf20 screen_left\cf10 , \cf20 screen_top\cf10 );\
        \cf20 SDL_ShowWindow\cf10 (\cf20 win\cf10 );\
\
        \cf18 Uint32\cf10  pixformat = \cf20 SDL_PIXELFORMAT_IYUV\cf10 ;\
\
        \cf8 //create texture for render\cf10 \
        \cf20 texture\cf10  = \cf20 SDL_CreateTexture\cf10 (\cf20 renderer\cf10 ,\
                                    pixformat,\
                                    \cf20 SDL_TEXTUREACCESS_STREAMING\cf10 ,\
                                    \cf20 screen_width\cf10 ,\
                                    \cf20 screen_height\cf10 );\
        \cf20 resize\cf10  = \cf14 0\cf10 ;\
    \}\
\
    vp = &is->\cf20 pictq\cf10 [is->\cf20 pictq_rindex\cf10 ];\
\
    \cf8 // 
\f0 \'e4\'d6\'c8\'be\'b2\'a5\'b7\'c5
\f2 \cf10 \
    
\f5\b \cf13 if
\f2\b0 \cf10  (vp->\cf20 frame\cf10 ) \{\
        \cf20 SDL_UpdateYUVTexture\cf10 (\cf20 texture\cf10 , 
\f5\b \cf13 NULL
\f2\b0 \cf10 ,\
                             vp->\cf20 frame\cf10 ->\cf20 data\cf10 [\cf14 0\cf10 ], vp->\cf20 frame\cf10 ->\cf20 linesize\cf10 [\cf14 0\cf10 ],\
                             vp->\cf20 frame\cf10 ->\cf20 data\cf10 [\cf14 1\cf10 ], vp->\cf20 frame\cf10 ->\cf20 linesize\cf10 [\cf14 1\cf10 ],\
                             vp->\cf20 frame\cf10 ->\cf20 data\cf10 [\cf14 2\cf10 ], vp->\cf20 frame\cf10 ->\cf20 linesize\cf10 [\cf14 2\cf10 ]);\
\
        rect.\cf20 x\cf10  = \cf14 0\cf10 ;\
        rect.\cf20 y\cf10  = \cf14 0\cf10 ;\
        rect.\cf20 w\cf10  = is->\cf20 video_ctx\cf10 ->\cf20 width\cf10 ;\
        rect.\cf20 h\cf10  = is->\cf20 video_ctx\cf10 ->\cf20 height\cf10 ;\
        \cf20 SDL_LockMutex\cf10 (\cf20 text_mutex\cf10 );\
        \cf20 SDL_RenderClear\cf10 (\cf20 renderer\cf10 );\
        \cf20 SDL_RenderCopy\cf10 (\cf20 renderer\cf10 , \cf20 texture\cf10 , 
\f5\b \cf13 NULL
\f2\b0 \cf10 , &rect);\
        \cf20 SDL_RenderPresent\cf10 (\cf20 renderer\cf10 );\
        \cf20 SDL_UnlockMutex\cf10 (\cf20 text_mutex\cf10 );\
    \}\
\}\
\
\cf21 ///
\f6 \cf8 / 
\f0 \'ca\'d3\'c6\'b5\'cb\'a2\'d0\'c2\'b2\'a5\'b7\'c5\'a3\'ac\'b2\'a2\'d4\'a4\'b2\'e2\'cf\'c2\'d2\'bb\'d6\'a1\'b5\'c4\'b2\'a5\'b7\'c5\'ca\'b1\'bc\'e4\'a3\'ac\'c9\'e8\'d6\'c3\'d0\'c2\'b5\'c4\'b6\'a8\'ca\'b1\'c6\'f7
\f2 \cf10 \

\f5\b \cf13 void
\f2\b0 \cf10  \cf16 video_refresh_timer\cf10 (
\f5\b \cf13 void
\f2\b0 \cf10  *userdata) \{\
\
    \cf18 VideoState\cf10  *is = (\cf18 VideoState\cf10  *) userdata;\
    \cf18 VideoPicture\cf10  *vp;\
    
\f5\b \cf13 double
\f2\b0 \cf10  actual_delay, delay, sync_threshold, ref_clock, diff;\
\
    
\f5\b \cf13 if
\f2\b0 \cf10  (is->\cf20 video_st\cf10 ) \{\
        
\f5\b \cf13 if
\f2\b0 \cf10  (is->\cf20 pictq_size\cf10  == \cf14 0\cf10 ) \{\
            \cf20 schedule_refresh\cf10 (is, \cf14 1\cf10 );\
        \} 
\f5\b \cf13 else
\f2\b0 \cf10  \{\
            \cf8 // 
\f0 \'b4\'d3\'ca\'fd\'d7\'e9\'d6\'d0\'c8\'a1\'b3\'f6\'d2\'bb\'d6\'a1\'ca\'d3\'c6\'b5\'d6\'a1
\f2 \cf10 \
            vp = &is->\cf20 pictq\cf10 [is->\cf20 pictq_rindex\cf10 ];\
\
            is->\cf20 video_current_pts\cf10  = vp->\cf20 pts\cf10 ;\
            is->\cf20 video_current_pts_time\cf10  = \cf20 av_gettime\cf10 ();\
            \cf8 // 
\f0 \'b5\'b1\'c7\'b0
\f2 Frame
\f0 \'ca\'b1\'bc\'e4\'bc\'f5\'c8\'a5\'c9\'cf\'d2\'bb\'d6\'a1\'b5\'c4\'ca\'b1\'bc\'e4\'a3\'ac\'bb\'f1\'c8\'a1\'c1\'bd\'d6\'a1\'bc\'e4\'b5\'c4\'ca\'b1\'b2\'ee
\f2 \cf10 \
            delay = vp->\cf20 pts\cf10  - is->\cf20 frame_last_pts\cf10 ;\
            
\f5\b \cf13 if
\f2\b0 \cf10  (delay <= \cf14 0\cf10  || delay >= \cf14 1.0\cf10 ) \{\
                \cf8 // 
\f0 \'d1\'d3\'ca\'b1\'d0\'a1\'d3\'da
\f2 0
\f0 \'bb\'f2\'b4\'f3\'d3\'da
\f2 1
\f0 \'c3\'eb\'a3\'a8\'cc\'ab\'b3\'a4\'a3\'a9\'b6\'bc\'ca\'c7\'b4\'ed\'ce\'f3\'b5\'c4\'a3\'ac\'bd\'ab\'d1\'d3\'ca\'b1\'ca\'b1\'bc\'e4\'c9\'e8\'d6\'c3\'ce\'aa\'c9\'cf\'d2\'bb\'b4\'ce\'b5\'c4\'d1\'d3\'ca\'b1\'ca\'b1\'bc\'e4
\f2 \cf10 \
                delay = is->\cf20 frame_last_delay\cf10 ;\
            \}\
            \cf8 // 
\f0 \'b1\'a3\'b4\'e6\'d1\'d3\'ca\'b1\'ba\'cd
\f2 PTS
\f0 \'a3\'ac\'b5\'c8\'b4\'fd\'cf\'c2\'b4\'ce\'ca\'b9\'d3\'c3
\f2 \cf10 \
            is->\cf20 frame_last_delay\cf10  = delay;\
            is->\cf20 frame_last_pts\cf10  = vp->\cf20 pts\cf10 ;\
\
            \cf8 // 
\f0 \'bb\'f1\'c8\'a1\'d2\'f4\'c6\'b5
\f2 Audio_Clock\cf10 \
            ref_clock = \cf20 get_audio_clock\cf10 (is);\
            \cf8 // 
\f0 \'b5\'c3\'b5\'bd\'b5\'b1\'c7\'b0
\f2 PTS
\f0 \'ba\'cd
\f2 Audio_Clock
\f0 \'b5\'c4\'b2\'ee\'d6\'b5
\f2 \cf10 \
            diff = vp->\cf20 pts\cf10  - ref_clock;\
\
            \cf8 /* Skip or repeat the frame. Take delay into account\cf10 \
\cf8                FFPlay still doesn't "know if this is the best guess." */\cf10 \
            sync_threshold = (delay > \cf11 AV_SYNC_THRESHOLD\cf10 ) ? delay : \cf11 AV_SYNC_THRESHOLD\cf10 ;\
            
\f5\b \cf13 if
\f2\b0 \cf10  (\cf19 fabs\cf10 (diff) < \cf11 AV_NOSYNC_THRESHOLD\cf10 ) \{\
                
\f5\b \cf13 if
\f2\b0 \cf10  (diff <= -sync_threshold) \{\
                    delay = \cf14 0\cf10 ;\
                \} 
\f5\b \cf13 else
\f2\b0 \cf10  
\f5\b \cf13 if
\f2\b0 \cf10  (diff >= sync_threshold) \{\
                    delay = \cf14 2\cf10  * delay;\
                \}\
            \}\
            is->\cf20 frame_timer\cf10  += delay;\
            \cf8 // 
\f0 \'d7\'ee\'d6\'d5\'d5\'e6\'d5\'fd\'d2\'aa\'d1\'d3\'ca\'b1\'b5\'c4\'ca\'b1\'bc\'e4
\f2 \cf10 \
            actual_delay = is->\cf20 frame_timer\cf10  - (\cf20 av_gettime\cf10 () / \cf14 1000000.0\cf10 );\
            
\f5\b \cf13 if
\f2\b0 \cf10  (actual_delay < \cf14 0.010\cf10 ) \{\
                \cf8 // 
\f0 \'d1\'d3\'ca\'b1\'ca\'b1\'bc\'e4\'b9\'fd\'d0\'a1\'be\'cd\'c9\'e8\'d6\'c3\'d7\'ee\'d0\'a1\'d6\'b5
\f2 \cf10 \
                actual_delay = \cf14 0.010\cf10 ;\
            \}\
            \cf8 // 
\f0 \'b8\'f9\'be\'dd\'d1\'d3\'ca\'b1\'ca\'b1\'bc\'e4\'d6\'d8\'d0\'c2\'c9\'e8\'d6\'c3\'b6\'a8\'ca\'b1\'c6\'f7\'a3\'ac\'cb\'a2\'d0\'c2\'ca\'d3\'c6\'b5
\f2 \cf10 \
            \cf20 schedule_refresh\cf10 (is, (
\f5\b \cf13 int
\f2\b0 \cf10 ) (actual_delay * \cf14 1000\cf10  + \cf14 0.5\cf10 ));\
\
            \cf8 // 
\f0 \'ca\'d3\'c6\'b5\'d6\'a1\'cf\'d4\'ca\'be
\f2 \cf10 \
            \cf20 video_display\cf10 (is);\
\
            \cf8 // 
\f0 \'b8\'fc\'d0\'c2\'ca\'d3\'c6\'b5\'d6\'a1\'ca\'fd\'d7\'e9\'cf\'c2\'b1\'ea
\f2 \cf10 \
            
\f5\b \cf13 if
\f2\b0 \cf10  (++is->\cf20 pictq_rindex\cf10  == \cf11 VIDEO_PICTURE_QUEUE_SIZE\cf10 ) \{\
                is->\cf20 pictq_rindex\cf10  = \cf14 0\cf10 ;\
            \}\
            \cf20 SDL_LockMutex\cf10 (is->\cf20 pictq_mutex\cf10 );\
            \cf8 // 
\f0 \'ca\'d3\'c6\'b5\'d6\'a1\'ca\'fd\'d7\'e9\'bc\'f5\'d2\'bb
\f2 \cf10 \
            is->\cf20 pictq_size\cf10 --;\
            \cf20 SDL_CondSignal\cf10 (is->\cf20 pictq_cond\cf10 );\
            \cf20 SDL_UnlockMutex\cf10 (is->\cf20 pictq_mutex\cf10 );\
        \}\
    \} 
\f5\b \cf13 else
\f2\b0 \cf10  \{\
        \cf20 schedule_refresh\cf10 (is, \cf14 100\cf10 );\
    \}\
\}\
\
\cf21 ///
\f6 \cf8 /
\f0 \'bd\'e2\'c2\'eb\'ba\'f3\'ca\'d3\'c6\'b5\'d6\'a1\'b1\'a3\'b4\'e6
\f2 \cf10 \

\f5\b \cf13 int
\f2\b0 \cf10  \cf16 queue_picture\cf10 (\cf18 VideoState\cf10  *is, \cf18 AVFrame\cf10  *pFrame, 
\f5\b \cf13 double
\f2\b0 \cf10  pts) \{\
\
    \cf18 VideoPicture\cf10  *vp;\
\
    \cf8 /* wait until we have space for a new pic */\cf10 \
    \cf20 SDL_LockMutex\cf10 (is->\cf20 pictq_mutex\cf10 );\
    
\f5\b \cf13 while
\f2\b0 \cf10  (is->\cf20 pictq_size\cf10  >= \cf11 VIDEO_PICTURE_QUEUE_SIZE\cf10  && !is->\cf20 quit\cf10 ) \{\
        \cf20 SDL_CondWait\cf10 (is->\cf20 pictq_cond\cf10 , is->\cf20 pictq_mutex\cf10 );\
    \}\
    \cf20 SDL_UnlockMutex\cf10 (is->\cf20 pictq_mutex\cf10 );\
\
    
\f5\b \cf13 if
\f2\b0 \cf10  (is->\cf20 quit\cf10 )\
        
\f5\b \cf13 return
\f2\b0 \cf10  -\cf14 1\cf10 ;\
\
    \cf8 // windex is set to 0 initially\cf10 \
    vp = &is->\cf20 pictq\cf10 [is->\cf20 pictq_windex\cf10 ];\
\
\
\cf8 //    /* allocate or resize the buffer! */\cf10 \
    
\f5\b \cf13 if
\f2\b0 \cf10  (!vp->\cf20 frame\cf10  ||\
        vp->\cf20 width\cf10  != is->\cf20 video_ctx\cf10 ->\cf20 width\cf10  ||\
        vp->\cf20 height\cf10  != is->\cf20 video_ctx\cf10 ->\cf20 height\cf10 ) \{\
\
        vp->\cf20 frame\cf10  = \cf20 av_frame_alloc\cf10 ();\
        
\f5\b \cf13 if
\f2\b0 \cf10  (is->\cf20 quit\cf10 ) \{\
            
\f5\b \cf13 return
\f2\b0 \cf10  -\cf14 1\cf10 ;\
        \}\
    \}\
\
    \cf8 /* We have a place to put our picture on the queue */\cf10 \
    
\f5\b \cf13 if
\f2\b0 \cf10  (vp->\cf20 frame\cf10 ) \{\
\
        vp->\cf20 pts\cf10  = pts;\
\
        vp->\cf20 frame\cf10  = pFrame;\
        \cf8 /* now we inform our display thread that we have a pic ready */\cf10 \
        
\f5\b \cf13 if
\f2\b0 \cf10  (++is->\cf20 pictq_windex\cf10  == \cf11 VIDEO_PICTURE_QUEUE_SIZE\cf10 ) \{\
            is->\cf20 pictq_windex\cf10  = \cf14 0\cf10 ;\
        \}\
\
        \cf20 SDL_LockMutex\cf10 (is->\cf20 pictq_mutex\cf10 );\
        is->\cf20 pictq_size\cf10 ++;\
        \cf20 SDL_UnlockMutex\cf10 (is->\cf20 pictq_mutex\cf10 );\
    \}\
    
\f5\b \cf13 return
\f2\b0 \cf10  \cf14 0\cf10 ;\
\}\
\
\cf21 ///
\f6 \cf8 /  
\f0 \'ca\'d3\'c6\'b5\'cd\'ac\'b2\'bd\'a3\'ac\'bb\'f1\'c8\'a1\'d5\'fd\'c8\'b7\'b5\'c4\'ca\'d3\'c6\'b5
\f6 PTS
\f2 \cf10 \

\f5\b \cf13 double
\f2\b0 \cf10  \cf16 synchronize_video\cf10 (\cf18 VideoState\cf10  *is, \cf18 AVFrame\cf10  *src_frame, 
\f5\b \cf13 double
\f2\b0 \cf10  pts) \{\
\
    
\f5\b \cf13 double
\f2\b0 \cf10  frame_delay;\
\
    
\f5\b \cf13 if
\f2\b0 \cf10  (pts != \cf14 0\cf10 ) \{\
        is->\cf20 video_clock\cf10  = pts;\
    \} 
\f5\b \cf13 else
\f2\b0 \cf10  \{\
        pts = is->\cf20 video_clock\cf10 ;\
    \}\
    \cf8 /* update the video clock */\cf10 \
    frame_delay = \cf20 av_q2d\cf10 (is->\cf20 video_ctx\cf10 ->\cf20 time_base\cf10 );\
    \cf8 /* if we are repeating a frame, adjust clock accordingly */\cf10 \
    frame_delay += src_frame->\cf20 repeat_pict\cf10  * (frame_delay * \cf14 0.5\cf10 );\
    is->\cf20 video_clock\cf10  += frame_delay;\
    
\f5\b \cf13 return
\f2\b0 \cf10  pts;\
\}\
\
\
\cf21 ///
\f6 \cf8 / 
\f0 \'ca\'d3\'c6\'b5\'bd\'e2\'c2\'eb
\f2 \cf10 \

\f5\b \cf13 int
\f2\b0 \cf10  \cf16 decode_video_thread\cf10 (
\f5\b \cf13 void
\f2\b0 \cf10  *arg) \{\
    \cf18 VideoState\cf10  *is = (\cf18 VideoState\cf10  *) arg;\
    \cf18 AVPacket\cf10  pkt1, *packet = &pkt1;\
    \cf18 AVFrame\cf10  *pFrame;\
    
\f5\b \cf13 double
\f2\b0 \cf10  pts;\
\
    pFrame = \cf20 av_frame_alloc\cf10 ();\
\
    
\f5\b \cf13 for
\f2\b0 \cf10  (;;) \{\
        
\f5\b \cf13 if
\f2\b0 \cf10  (\cf20 packet_queue_get\cf10 (&is->\cf20 videoq\cf10 , packet, \cf14 1\cf10 ) < \cf14 0\cf10 ) \{\
            \cf8 // means we quit getting packets\cf10 \
            
\f5\b \cf13 break
\f2\b0 \cf10 ;\
        \}\
\
        \cf8 // Decode video frame\cf10 \
        \cf20 avcodec_send_packet\cf10 (is->\cf20 video_ctx\cf10 , packet);\
        \
        
\f5\b \cf13 while
\f2\b0 \cf10  (\cf20 avcodec_receive_frame\cf10 (is->\cf20 video_ctx\cf10 , pFrame) == \cf14 0\cf10 ) \{\
            
\f5\b \cf13 if
\f2\b0 \cf10  ((pts = pFrame->\cf20 best_effort_timestamp\cf10 ) != \cf11 AV_NOPTS_VALUE\cf10 ) \{\
            \} 
\f5\b \cf13 else
\f2\b0 \cf10  \{\
                pts = \cf14 0\cf10 ;\
            \}\
            pts *= \cf20 av_q2d\cf10 (is->\cf20 video_st\cf10 ->\cf20 time_base\cf10 );\
\
            pts = \cf20 synchronize_video\cf10 (is, pFrame, pts);\
            
\f5\b \cf13 if
\f2\b0 \cf10  (\cf20 queue_picture\cf10 (is, pFrame, pts) < \cf14 0\cf10 ) \{\
                
\f5\b \cf13 break
\f2\b0 \cf10 ;\
            \}\
            \cf20 av_packet_unref\cf10 (packet);\
        \}\
    \}\
    \cf20 av_frame_free\cf10 (&pFrame);\
    
\f5\b \cf13 return
\f2\b0 \cf10  \cf14 0\cf10 ;\
\}\
\
\cf21 ///
\f6 \cf8 / 
\f0 \'b4\'f2\'bf\'aa\'c1\'f7\'a3\'ac\'d7\'bc\'b1\'b8\'bd\'e2\'c2\'eb
\f2 \cf10 \

\f5\b \cf13 int
\f2\b0 \cf10  \cf16 stream_component_open\cf10 (\cf18 VideoState\cf10  *is, 
\f5\b \cf13 int
\f2\b0 \cf10  stream_index) \{\
\
    \cf18 AVFormatContext\cf10  *pFormatCtx = is->\cf20 pFormatCtx\cf10 ;\
    \cf18 AVCodecContext\cf10  *codecCtx = 
\f5\b \cf13 NULL
\f2\b0 \cf10 ;\
    \cf18 AVCodec\cf10  *codec = 
\f5\b \cf13 NULL
\f2\b0 \cf10 ;\
    \cf18 SDL_AudioSpec\cf10  wanted_spec;\
\
    
\f5\b \cf13 if
\f2\b0 \cf10  (stream_index < \cf14 0\cf10  || stream_index >= pFormatCtx->\cf20 nb_streams\cf10 ) \{\
        
\f5\b \cf13 return
\f2\b0 \cf10  -\cf14 1\cf10 ;\
    \}\
\
    codecCtx = \cf20 avcodec_alloc_context3\cf10 (
\f5\b \cf13 NULL
\f2\b0 \cf10 );\
    
\f5\b \cf13 int
\f2\b0 \cf10  ret = \cf20 avcodec_parameters_to_context\cf10 (codecCtx, pFormatCtx->\cf20 streams\cf10 [stream_index]->\cf20 codecpar\cf10 );\
    
\f5\b \cf13 if
\f2\b0 \cf10  (ret < \cf14 0\cf10 )\
        
\f5\b \cf13 return
\f2\b0 \cf10  -\cf14 1\cf10 ;\
\
    codec = \cf20 avcodec_find_decoder\cf10 (codecCtx->\cf20 codec_id\cf10 );\
    
\f5\b \cf13 if
\f2\b0 \cf10  (!codec) \{\
        \cf19 fprintf\cf10 (\cf11 stderr\cf10 , \cf12 "Unsupported codec!\\n"\cf10 );\
        
\f5\b \cf13 return
\f2\b0 \cf10  -\cf14 1\cf10 ;\
    \}\
\
    \cf8 // 
\f0 \'b4\'f2\'bf\'aa\'bd\'e2\'c2\'eb\'c6\'f7
\f2 \cf10 \
    
\f5\b \cf13 if
\f2\b0 \cf10  (\cf20 avcodec_open2\cf10 (codecCtx, codec, 
\f5\b \cf13 NULL
\f2\b0 \cf10 ) < \cf14 0\cf10 ) \{\
        \cf19 fprintf\cf10 (\cf11 stderr\cf10 , \cf12 "Unsupported codec!\\n"\cf10 );\
        
\f5\b \cf13 return
\f2\b0 \cf10  -\cf14 1\cf10 ;\
    \}\
\
    
\f5\b \cf13 switch
\f2\b0 \cf10  (codecCtx->\cf20 codec_type\cf10 ) \{\
        \cf8 // 
\f0 \'d2\'f4\'c6\'b5\'c1\'f7\'b2\'ce\'ca\'fd\'c5\'e4\'d6\'c3\'a3\'ac\'b4\'f2\'bf\'aa\'d2\'f4\'c6\'b5\'c9\'e8\'b1\'b8\'a3\'ac\'b2\'a5\'b7\'c5\'d2\'f4\'c6\'b5
\f2 \cf10 \
        
\f5\b \cf13 case
\f2\b0 \cf10  \cf20 AVMEDIA_TYPE_AUDIO\cf10 : \{\
        \
            \cf8 // Set audio settings from codec info\cf10 \
            wanted_spec.\cf20 freq\cf10  = codecCtx->\cf20 sample_rate\cf10 ;\
            wanted_spec.\cf20 format\cf10  = \cf11 AUDIO_S16SYS\cf10 ;\
            wanted_spec.\cf20 channels\cf10  = \cf14 2\cf10 ;\cf8 //codecCtx->channels;\cf10 \
            wanted_spec.\cf20 silence\cf10  = \cf14 0\cf10 ;\
            wanted_spec.\cf20 samples\cf10  = \cf11 SDL_AUDIO_BUFFER_SIZE\cf10 ;\
            wanted_spec.\cf20 callback\cf10  = \cf20 audio_callback\cf10 ;\
            wanted_spec.\cf20 userdata\cf10  = is;\
\
            \cf19 fprintf\cf10 (\cf11 stderr\cf10 , \cf12 "wanted spec: channels:%d, sample_fmt:%d, sample_rate:%d \\n"\cf10 ,\
                    \cf14 2\cf10 , \cf11 AUDIO_S16SYS\cf10 , codecCtx->\cf20 sample_rate\cf10 );\
\
            \cf8 // 
\f0 \'b4\'f2\'bf\'aa\'d2\'f4\'c6\'b5\'c9\'e8\'b1\'b8
\f2 \cf10 \
            
\f5\b \cf13 if
\f2\b0 \cf10  (\cf20 SDL_OpenAudio\cf10 (&wanted_spec, 
\f5\b \cf13 NULL
\f2\b0 \cf10 ) < \cf14 0\cf10 ) \{\
                \cf19 fprintf\cf10 (\cf11 stderr\cf10 , \cf12 "SDL_OpenAudio: %s\\n"\cf10 , \cf20 SDL_GetError\cf10 ());\
                
\f5\b \cf13 return
\f2\b0 \cf10  -\cf14 1\cf10 ;\
            \}\
\
            is->\cf20 audioStream\cf10  = stream_index;\
            is->\cf20 audio_st\cf10  = pFormatCtx->\cf20 streams\cf10 [stream_index];\
            is->\cf20 audio_ctx\cf10  = codecCtx;\
            is->\cf20 audio_buf_size\cf10  = \cf14 0\cf10 ;\
\
            is->\cf20 audio_buf_index\cf10  = \cf14 0\cf10 ;\
            \cf19 memset\cf10 (&is->\cf20 audio_pkt\cf10 , \cf14 0\cf10 , 
\f5\b \cf13 sizeof
\f2\b0 \cf10 (is->\cf20 audio_pkt\cf10 ));\
            \cf20 packet_queue_init\cf10 (&is->\cf20 audioq\cf10 );\
\
            \cf8 //Out Audio Param\cf10 \
            \cf17 uint64_t\cf10  out_channel_layout = \cf11 AV_CH_LAYOUT_STEREO\cf10 ;\
\
            
\f5\b \cf13 int
\f2\b0 \cf10  out_nb_samples = is->\cf20 audio_ctx\cf10 ->\cf20 frame_size\cf10 ;\
\
            
\f5\b \cf13 int
\f2\b0 \cf10  out_sample_rate = is->\cf20 audio_ctx\cf10 ->\cf20 sample_rate\cf10 ;\
            
\f5\b \cf13 int
\f2\b0 \cf10  out_channels = \cf20 av_get_channel_layout_nb_channels\cf10 (out_channel_layout);\
\
\
            \cf17 int64_t\cf10  in_channel_layout = \cf20 av_get_default_channel_layout\cf10 (is->\cf20 audio_ctx\cf10 ->\cf20 channels\cf10 );\
\
            \cf8 // 
\f0 \'d2\'f4\'c6\'b5\'d6\'d8\'b2\'c9\'d1\'f9
\f2 \cf10 \
            
\f5\b \cf13 struct
\f2\b0 \cf10  \cf15 SwrContext\cf10  *audio_convert_ctx;\
            audio_convert_ctx = \cf20 swr_alloc\cf10 ();\
            \cf20 swr_alloc_set_opts\cf10 (audio_convert_ctx,\
                               out_channel_layout,\
                               \cf20 AV_SAMPLE_FMT_S16\cf10 ,\
                               out_sample_rate,\
                               in_channel_layout,\
                               is->\cf20 audio_ctx\cf10 ->\cf20 sample_fmt\cf10 ,\
                               is->\cf20 audio_ctx\cf10 ->\cf20 sample_rate\cf10 ,\
                               \cf14 0\cf10 ,\
                               
\f5\b \cf13 NULL
\f2\b0 \cf10 );\
\
            \cf20 swr_init\cf10 (audio_convert_ctx);\
            is->\cf20 audio_swr_ctx\cf10  = audio_convert_ctx;\
\
            \cf8 // 
\f0 \'bf\'aa\'ca\'bc\'b2\'a5\'b7\'c5\'d2\'f4\'c6\'b5\'a3\'ac
\f2 audio_callback
\f0 \'bb\'d8\'b5\'f7
\f2 \cf10 \
            \cf20 SDL_PauseAudio\cf10 (\cf14 0\cf10 );\
\
            
\f5\b \cf13 break
\f2\b0 \cf10 ;\
        \}\
            \cf8 // 
\f0 \'ca\'d3\'c6\'b5\'b2\'a5\'b7\'c5\'d7\'bc\'b1\'b8\'a3\'ac\'bd\'e2\'c2\'eb\'a1\'a2\'b2\'a5\'b7\'c5\'ca\'d3\'c6\'b5
\f2 \cf10 \
        
\f5\b \cf13 case
\f2\b0 \cf10  \cf20 AVMEDIA_TYPE_VIDEO\cf10 : \{\
            is->\cf20 videoStream\cf10  = stream_index;\
            is->\cf20 video_st\cf10  = pFormatCtx->\cf20 streams\cf10 [stream_index];\
            is->\cf20 video_ctx\cf10  = codecCtx;\
\
            is->\cf20 frame_timer\cf10  = (
\f5\b \cf13 double
\f2\b0 \cf10 ) \cf20 av_gettime\cf10 () / \cf14 1000000.0\cf10 ;\
            is->\cf20 frame_last_delay\cf10  = \cf14 40e-3\cf10 ;\
            is->\cf20 video_current_pts_time\cf10  = \cf20 av_gettime\cf10 ();\
\
            \cf20 packet_queue_init\cf10 (&is->\cf20 videoq\cf10 );\
\
            \cf8 // 
\f0 \'b4\'b4\'bd\'a8\'ca\'d3\'c6\'b5\'bd\'e2\'c2\'eb\'cf\'df\'b3\'cc
\f2 \cf10 \
            is->\cf20 video_tid\cf10  = \cf20 SDL_CreateThread\cf10 (\cf20 decode_video_thread\cf10 , \cf12 "decode_video_thread"\cf10 , is);\
            
\f5\b \cf13 break
\f2\b0 \cf10 ;\
        \}\
        
\f5\b \cf13 default
\f2\b0 \cf10 :\
            
\f5\b \cf13 break
\f2\b0 \cf10 ;\
    \}\
    
\f5\b \cf13 return
\f2\b0 \cf10  \cf14 0\cf10 ;\
\}\
\
\cf8 // 
\f0 \'bd\'e2\'b8\'b4\'d3\'c3\'a3\'ac\'bb\'f1\'c8\'a1\'d2\'f4\'c6\'b5\'a1\'a2\'ca\'d3\'c6\'b5\'c1\'f7\'a3\'ac\'b2\'a2\'bd\'ab
\f2 packet
\f0 \'b7\'c5\'c8\'eb\'b6\'d3\'c1\'d0\'d6\'d0
\f2 \cf10 \

\f5\b \cf13 int
\f2\b0 \cf10  \cf16 demux_thread\cf10 (
\f5\b \cf13 void
\f2\b0 \cf10  *arg) \{\
\
    
\f5\b \cf13 int
\f2\b0 \cf10  err_code;\
    
\f5\b \cf13 char
\f2\b0 \cf10  errors[\cf14 1024\cf10 ] = \{\cf14 0\cf10 ,\};\
\
    
\f5\b \cf13 int
\f2\b0 \cf10  w, h;\
\
    \cf18 VideoState\cf10  *is = (\cf18 VideoState\cf10  *) arg;\
    \cf18 AVFormatContext\cf10  *pFormatCtx = 
\f5\b \cf13 NULL
\f2\b0 \cf10 ;\
    \cf18 AVPacket\cf10  pkt1, *packet = &pkt1;\
\
    
\f5\b \cf13 int
\f2\b0 \cf10  video_index = -\cf14 1\cf10 ;\
    
\f5\b \cf13 int
\f2\b0 \cf10  audio_index = -\cf14 1\cf10 ;\
    
\f5\b \cf13 int
\f2\b0 \cf10  i;\
\
    is->\cf20 videoStream\cf10  = -\cf14 1\cf10 ;\
    is->\cf20 audioStream\cf10  = -\cf14 1\cf10 ;\
\
    \cf20 global_video_state\cf10  = is;\
\
    \cf8 /* open input file, and allocate format context */\cf10 \
    
\f5\b \cf13 if
\f2\b0 \cf10  ((err_code = \cf20 avformat_open_input\cf10 (&pFormatCtx, is->\cf20 filename\cf10 , 
\f5\b \cf13 NULL
\f2\b0 \cf10 , 
\f5\b \cf13 NULL
\f2\b0 \cf10 )) < \cf14 0\cf10 ) \{\
        \cf20 av_strerror\cf10 (err_code, errors, \cf14 1024\cf10 );\
        \cf19 fprintf\cf10 (\cf11 stderr\cf10 , \cf12 "Could not open source file %s, %d(%s)\\n"\cf10 , is->\cf20 filename\cf10 , err_code, errors);\
        
\f5\b \cf13 return
\f2\b0 \cf10  -\cf14 1\cf10 ;\
    \}\
\
    is->\cf20 pFormatCtx\cf10  = pFormatCtx;\
\
    \cf8 // Retrieve stream information\cf10 \
    
\f5\b \cf13 if
\f2\b0 \cf10  (\cf20 avformat_find_stream_info\cf10 (pFormatCtx, 
\f5\b \cf13 NULL
\f2\b0 \cf10 ) < \cf14 0\cf10 )\
        
\f5\b \cf13 return
\f2\b0 \cf10  -\cf14 1\cf10 ; \cf8 // Couldn't find stream information\cf10 \
\
    \cf8 // Dump information about file onto standard error\cf10 \
    \cf20 av_dump_format\cf10 (pFormatCtx, \cf14 0\cf10 , is->\cf20 filename\cf10 , \cf14 0\cf10 );\
\
    \cf8 // Find the first video stream\cf10 \
    
\f5\b \cf13 for
\f2\b0 \cf10  (i = \cf14 0\cf10 ; i < pFormatCtx->\cf20 nb_streams\cf10 ; i++) \{\
        
\f5\b \cf13 if
\f2\b0 \cf10  (pFormatCtx->\cf20 streams\cf10 [i]->\cf20 codecpar\cf10 ->\cf20 codec_type\cf10  == \cf20 AVMEDIA_TYPE_VIDEO\cf10  &&\
            video_index < \cf14 0\cf10 ) \{\
            video_index = i;\
        \}\
        
\f5\b \cf13 if
\f2\b0 \cf10  (pFormatCtx->\cf20 streams\cf10 [i]->\cf20 codecpar\cf10 ->\cf20 codec_type\cf10  == \cf20 AVMEDIA_TYPE_AUDIO\cf10  &&\
            audio_index < \cf14 0\cf10 ) \{\
            audio_index = i;\
        \}\
    \}\
    
\f5\b \cf13 if
\f2\b0 \cf10  (audio_index >= \cf14 0\cf10 ) \{\
        \cf20 stream_component_open\cf10 (is, audio_index);\
    \}\
    
\f5\b \cf13 if
\f2\b0 \cf10  (video_index >= \cf14 0\cf10 ) \{\
        \cf20 stream_component_open\cf10 (is, video_index);\
    \}\
\
    
\f5\b \cf13 if
\f2\b0 \cf10  (is->\cf20 videoStream\cf10  < \cf14 0\cf10  || is->\cf20 audioStream\cf10  < \cf14 0\cf10 ) \{\
        \cf19 fprintf\cf10 (\cf11 stderr\cf10 , \cf12 "%s: could not open codecs\\n"\cf10 , is->\cf20 filename\cf10 );\
        
\f5\b \cf13 goto
\f2\b0 \cf10  fail;\
    \}\
\
    \cf20 screen_width\cf10  = is->\cf20 video_ctx\cf10 ->\cf20 width\cf10 ;\
    \cf20 screen_height\cf10  = is->\cf20 video_ctx\cf10 ->\cf20 height\cf10 ;\
\
\
    
\f5\b \cf13 for
\f2\b0 \cf10  (;;) \{\
        
\f5\b \cf13 if
\f2\b0 \cf10  (is->\cf20 quit\cf10 ) \{\
            
\f5\b \cf13 break
\f2\b0 \cf10 ;\
        \}\
        \cf8 // seek stuff goes here\cf10 \
        
\f5\b \cf13 if
\f2\b0 \cf10  (is->\cf20 audioq\cf10 .\cf20 size\cf10  > \cf11 MAX_AUDIOQ_SIZE\cf10  ||\
            is->\cf20 videoq\cf10 .\cf20 size\cf10  > \cf11 MAX_VIDEOQ_SIZE\cf10 ) \{\
            \cf20 SDL_Delay\cf10 (\cf14 10\cf10 );\
            
\f5\b \cf13 continue
\f2\b0 \cf10 ;\
        \}\
        
\f5\b \cf13 int
\f2\b0 \cf10  ret = \cf14 0\cf10 ;\
        ret = \cf20 av_read_frame\cf10 (is->\cf20 pFormatCtx\cf10 , packet);\
        
\f5\b \cf13 if
\f2\b0 \cf10  (ret < \cf14 0\cf10 ) \{\
            \cf19 printf\cf10 (\cf12 "%d.\\n"\cf10 ,ret);\
            
\f5\b \cf13 if
\f2\b0 \cf10  (is->\cf20 pFormatCtx\cf10 ->\cf20 pb\cf10 ->\cf20 error\cf10  == \cf14 0\cf10 ) \{\
                \cf20 SDL_Delay\cf10 (\cf14 100\cf10 ); \cf8 /* no error; wait for user input */\cf10 \
                
\f5\b \cf13 continue
\f2\b0 \cf10 ;\
            \} 
\f5\b \cf13 else
\f2\b0 \cf10  \{\
                
\f5\b \cf13 break
\f2\b0 \cf10 ;\
            \}\
        \}\
        \cf8 // Is this a packet from the video stream?\cf10 \
        
\f5\b \cf13 if
\f2\b0 \cf10  (packet->\cf20 stream_index\cf10  == is->\cf20 videoStream\cf10 ) \{\
            \cf20 packet_queue_put\cf10 (&is->\cf20 videoq\cf10 , packet);\
        \} 
\f5\b \cf13 else
\f2\b0 \cf10  
\f5\b \cf13 if
\f2\b0 \cf10  (packet->\cf20 stream_index\cf10  == is->\cf20 audioStream\cf10 ) \{\
            \cf20 packet_queue_put\cf10 (&is->\cf20 audioq\cf10 , packet);\
        \} 
\f5\b \cf13 else
\f2\b0 \cf10  \{\
            \cf20 av_packet_unref\cf10 (packet);\
        \}\
    \}\
    \cf8 /* all done - wait for it */\cf10 \
    
\f5\b \cf13 while
\f2\b0 \cf10  (!is->\cf20 quit\cf10 ) \{\
        \cf20 SDL_Delay\cf10 (\cf14 100\cf10 );\
    \}\
\
    fail:\
    
\f5\b \cf13 if
\f2\b0 \cf10  (\cf14 1\cf10 ) \{\
        \cf18 SDL_Event\cf10  event;\
        event.\cf20 type\cf10  = \cf11 FF_QUIT_EVENT\cf10 ;\
        event.\cf20 user\cf10 .\cf20 data1\cf10  = is;\
        \cf20 SDL_PushEvent\cf10 (&event);\
    \}\
    
\f5\b \cf13 return
\f2\b0 \cf10  \cf14 0\cf10 ;\
\}\
\

\f5\b \cf13 int
\f2\b0 \cf10  \cf16 main\cf10 (
\f5\b \cf13 int
\f2\b0 \cf10  argc, 
\f5\b \cf13 char
\f2\b0 \cf10  *argv[]) \{\
\
    
\f5\b \cf13 char
\f2\b0 \cf10  *file = \cf12 "/Users/qiansheng/Downloads/test.mp4"\cf10 ;\
\
    \cf18 SDL_Event\cf10  event;\
\
    \cf18 VideoState\cf10  *is;\
\
    is = (\cf18 VideoState\cf10  *)\cf20 av_mallocz\cf10 (
\f5\b \cf13 sizeof
\f2\b0 \cf10 (\cf18 VideoState\cf10 ));\
\
    
\f5\b \cf13 if
\f2\b0 \cf10  (\cf20 SDL_Init\cf10 (\cf11 SDL_INIT_VIDEO\cf10  | \cf11 SDL_INIT_AUDIO\cf10  | \cf11 SDL_INIT_TIMER\cf10 )) \{\
        \cf19 fprintf\cf10 (\cf11 stderr\cf10 , \cf12 "Could not initialize SDL - %s\\n"\cf10 , \cf20 SDL_GetError\cf10 ());\
        \cf19 exit\cf10 (\cf14 1\cf10 );\
    \}\
\
    \cf8 //
\f0 \'b4\'b4\'bd\'a8
\f2 SDL Window\cf10 \
    \cf20 win\cf10  = \cf20 SDL_CreateWindow\cf10 (\cf12 "Media Player"\cf10 ,\
                           \cf14 100\cf10 ,\
                           \cf14 100\cf10 ,\
                           \cf14 640\cf10 , \cf14 480\cf10 ,\
                           \cf20 SDL_WINDOW_RESIZABLE\cf10 );\
    
\f5\b \cf13 if
\f2\b0 \cf10  (!\cf20 win\cf10 ) \{\
        \cf19 fprintf\cf10 (\cf11 stderr\cf10 , \cf12 "\\nSDL: could not set video mode:%s - exiting\\n"\cf10 , \cf20 SDL_GetError\cf10 ());\
        \cf19 exit\cf10 (\cf14 1\cf10 );\
    \}\
\
    \cf20 renderer\cf10  = \cf20 SDL_CreateRenderer\cf10 (\cf20 win\cf10 , -\cf14 1\cf10 , \cf14 0\cf10 );\
    \cf20 text_mutex\cf10  = \cf20 SDL_CreateMutex\cf10 ();\
    \cf19 strlcpy\cf10 (is->\cf20 filename\cf10 , file, 
\f5\b \cf13 sizeof
\f2\b0 \cf10 (is->\cf20 filename\cf10 ));\
    is->\cf20 pictq_mutex\cf10  = \cf20 SDL_CreateMutex\cf10 ();\
    is->\cf20 pictq_cond\cf10  = \cf20 SDL_CreateCond\cf10 ();\
\
    \cf8 // 
\f0 \'b6\'a8\'ca\'b1\'cb\'a2\'d0\'c2\'c6\'f7
\f2 \cf10 \
    \cf20 schedule_refresh\cf10 (is, \cf14 40\cf10 );\
\
    \cf8 // 
\f0 \'b4\'b4\'bd\'a8\'bd\'e2\'b8\'b4\'d3\'c3\'cf\'df\'b3\'cc
\f2 \cf10 \
    is->\cf20 parse_tid\cf10  = \cf20 SDL_CreateThread\cf10 (\cf20 demux_thread\cf10 , \cf12 "demux_thread"\cf10 , is);\
    
\f5\b \cf13 if
\f2\b0 \cf10  (!is->\cf20 parse_tid\cf10 ) \{\
        \cf20 av_free\cf10 (is);\
        
\f5\b \cf13 return
\f2\b0 \cf10  -\cf14 1\cf10 ;\
    \}\
\
\
    
\f5\b \cf13 for
\f2\b0 \cf10  (;;) \{\
        \cf8 // 
\f0 \'b5\'c8\'b4\'fd
\f2 SDL
\f0 \'ca\'c2\'bc\'fe\'a3\'ac\'b7\'f1\'d4\'f2\'d7\'e8\'c8\'fb
\f2 \cf10 \
        \cf20 SDL_WaitEvent\cf10 (&event);\
        
\f5\b \cf13 switch
\f2\b0 \cf10  (event.\cf20 type\cf10 ) \{\
            
\f5\b \cf13 case
\f2\b0 \cf10  \cf11 FF_QUIT_EVENT\cf10 :\
            
\f5\b \cf13 case
\f2\b0 \cf10  \cf20 SDL_QUIT\cf10 : \cf8 // 
\f0 \'cd\'cb\'b3\'f6
\f2 \cf10 \
                is->\cf20 quit\cf10  = \cf14 1\cf10 ;\
                
\f5\b \cf13 goto
\f2\b0 \cf10  Destroy;\
            
\f5\b \cf13 case
\f2\b0 \cf10  \cf20 SDL_KEYDOWN\cf10 :\
                
\f5\b \cf13 if
\f2\b0 \cf10  (event.\cf20 key\cf10 .\cf20 keysym\cf10 .\cf20 sym\cf10  == \cf20 SDLK_ESCAPE\cf10 ) \{\
                    is->\cf20 quit\cf10  = \cf14 1\cf10 ;\
                    
\f5\b \cf13 goto
\f2\b0 \cf10  Destroy;\
                \}\
                
\f5\b \cf13 break
\f2\b0 \cf10 ;\
            
\f5\b \cf13 case
\f2\b0 \cf10  \cf11 FF_REFRESH_EVENT\cf10 : \cf8 // 
\f0 \'b6\'a8\'ca\'b1\'c6\'f7\'cb\'a2\'d0\'c2\'ca\'c2\'bc\'fe
\f2 \cf10 \
                \cf20 video_refresh_timer\cf10 (event.\cf20 user\cf10 .\cf20 data1\cf10 );\
                
\f5\b \cf13 break
\f2\b0 \cf10 ;\
            
\f5\b \cf13 default
\f2\b0 \cf10 :\
                
\f5\b \cf13 break
\f2\b0 \cf10 ;\
        \}\
    \}\
\
    Destroy:\
    \cf20 SDL_Quit\cf10 ();\
    
\f5\b \cf13 return
\f2\b0 \cf10  \cf14 0\cf10 ;\
\
\}\
\
\cf8 //int main(int argc, const char * argv[]) \{\cf10 \
\cf8 //    AVFormatContext *pFormatCtx;\cf10 \
\cf8 //    int  i, videoIndex;\cf10 \
\cf8 //    AVCodecContext *pCodecCtx;\cf10 \
\cf8 //    //AVCodec\cf10 \
\cf8 //    AVCodec *pCodec;\cf10 \
\cf8 //    AVFrame *pFrame, *pFrameYUV;\cf10 \
\cf8 //    unsigned char *out_buffer;\cf10 \
\cf8 //    AVPacket *packet;\cf10 \
\cf8 //    int y_size;\cf10 \
\cf8 //    int ret, got_picture;\cf10 \
\cf8 //    struct SwsContext *img_convert_ctx;\cf10 \
\cf8 //\cf10 \
\cf8 //    char filepath[] = "/Users/qiansheng/Downloads/test.mp4";\cf10 \
\cf8 //    //NSString *path =\cf10 \
\cf8 //\cf10 \
\cf8 //    FILE *fp_yuv = fopen("output.yuv", "wb+");\cf10 \
\cf8 //\cf10 \
\cf8 //    av_register_all();\cf10 \
\cf8 //    avformat_network_init();\cf10 \
\cf8 //    pFormatCtx = avformat_alloc_context();\cf10 \
\cf8 //\cf10 \
\cf8 //    if (avformat_open_input(&pFormatCtx, filepath, NULL, NULL)!=0) \{\cf10 \
\cf8 //        printf("Couldn't open input stream.\\n ");\cf10 \
\cf8 //        return -1;\cf10 \
\cf8 //    \}\cf10 \
\cf8 //\cf10 \
\cf8 //    if (avformat_find_stream_info(pFormatCtx, NULL)<0) \{\cf10 \
\cf8 //        printf("Coun't find stream information.\\n");\cf10 \
\cf8 //        return -1;\cf10 \
\cf8 //    \}\cf10 \
\cf8 //    videoIndex = -1;\cf10 \
\cf8 //    for (i=0; i<pFormatCtx->nb_streams; i++) \{\cf10 \
\cf8 //        if (pFormatCtx->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) \{\cf10 \
\cf8 //            videoIndex=i;\cf10 \
\cf8 //            break;;\cf10 \
\cf8 //        \}\cf10 \
\cf8 //    \}\cf10 \
\cf8 //    if (videoIndex == -1) \{\cf10 \
\cf8 //        printf("Did't find a video stream.\\n");\cf10 \
\cf8 //        return -1;\cf10 \
\cf8 //    \}\cf10 \
\cf8 //\cf10 \
\cf8 //   // if (pFormatCtx->streams[videoIndex]->codecpar->codec_id)\cf10 \
\cf8 //    AVCodecID codeId = pFormatCtx->streams[videoIndex]->codecpar->codec_id;\cf10 \
\cf8 //    //pCodecCtx = pFormatCtx->streams[videoIndex]->codec;\cf10 \
\cf8 //    pCodec = avcodec_find_decoder(codeId);\cf10 \
\cf8 //    if (pCodec == NULL) \{\cf10 \
\cf8 //        printf("Codec not found.\\n");\cf10 \
\cf8 //        return -1;\cf10 \
\cf8 //    \}\cf10 \
\cf8 //    pCodecCtx = avcodec_alloc_context3(pCodec);\cf10 \
\cf8 //    avcodec_parameters_to_context(pCodecCtx, pFormatCtx->streams[videoIndex]->codecpar);\cf10 \
\cf8 //\cf10 \
\cf8 //    if (avcodec_open2(pCodecCtx, pCodec, NULL) < 0) \{\cf10 \
\cf8 //        printf("Counld not open codec.\\n");\cf10 \
\cf8 //        return -1;\cf10 \
\cf8 //    \}\cf10 \
\cf8 //\cf10 \
\cf8 //    pFrame=av_frame_alloc();\cf10 \
\cf8 //    pFrameYUV=av_frame_alloc();\cf10 \
\cf8 //    out_buffer=(unsigned char*)av_malloc(av_image_get_buffer_size(AV_PIX_FMT_YUV420P, pCodecCtx->width, pCodecCtx->height, 1));\cf10 \
\cf8 //    av_image_fill_arrays(pFrameYUV->data, pFrameYUV->linesize, out_buffer, AV_PIX_FMT_YUV420P, pCodecCtx->width, pCodecCtx->height, 1);\cf10 \
\cf8 //\cf10 \
\cf8 //    packet=(AVPacket *)av_malloc(sizeof(AVPacket));\cf10 \
\cf8 //    //OUTPUT INFO\cf10 \
\cf8 //    printf("--------------File Information-----------\\n");\cf10 \
\cf8 //    av_dump_format(pFormatCtx, 0, filepath, 0);\cf10 \
\cf8 //    printf("-------------------------------------------");\cf10 \
\cf8 //    img_convert_ctx = sws_getContext(pCodecCtx->width, pCodecCtx->height, pCodecCtx->pix_fmt, pCodecCtx->width, pCodecCtx->height, AV_PIX_FMT_YUV420P, SWS_BICUBIC, NULL, NULL, NULL);\cf10 \
\cf8 //\cf10 \
\cf8 //    while (av_read_frame(pFormatCtx, packet)>=0) \{\cf10 \
\cf8 //        if(packet->stream_index==videoIndex)\{\cf10 \
\cf8 //                    ret = avcodec_decode_video2(pCodecCtx, pFrame, &got_picture, packet);\cf10 \
\cf8 //                    if(ret < 0)\{\cf10 \
\cf8 //                        printf("Decode Error.\\n");\cf10 \
\cf8 //                        return -1;\cf10 \
\cf8 //                    \}\cf10 \
\cf8 //                    if(got_picture)\{\cf10 \
\cf8 //                        sws_scale(img_convert_ctx, (const unsigned char* const*)pFrame->data, pFrame->linesize, 0, pCodecCtx->height,\cf10 \
\cf8 //                            pFrameYUV->data, pFrameYUV->linesize);\cf10 \
\cf8 //\cf10 \
\cf8 //                        y_size=pCodecCtx->width*pCodecCtx->height;\cf10 \
\cf8 //                        fwrite(pFrameYUV->data[0],1,y_size,fp_yuv);    //Y\cf10 \
\cf8 //                        fwrite(pFrameYUV->data[1],1,y_size/4,fp_yuv);  //U\cf10 \
\cf8 //                        fwrite(pFrameYUV->data[2],1,y_size/4,fp_yuv);  //V\cf10 \
\cf8 //                        printf("Succeed to decode 1 frame!\\n");\cf10 \
\cf8 //\cf10 \
\cf8 //                    \}\cf10 \
\cf8 //                \}\cf10 \
\cf8 //                av_free_packet(packet);\cf10 \
\cf8 //\cf10 \
\cf8 //    \}\cf10 \
\cf8 //\cf10 \
\cf8 //    while (1) \{\cf10 \
\cf8 //            ret = avcodec_decode_video2(pCodecCtx, pFrame, &got_picture, packet);\cf10 \
\cf8 //            if (ret < 0)\cf10 \
\cf8 //                break;\cf10 \
\cf8 //            if (!got_picture)\cf10 \
\cf8 //                break;\cf10 \
\cf8 //            sws_scale(img_convert_ctx, (const unsigned char* const*)pFrame->data, pFrame->linesize, 0, pCodecCtx->height,\cf10 \
\cf8 //                pFrameYUV->data, pFrameYUV->linesize);\cf10 \
\cf8 //\cf10 \
\cf8 //            int y_size=pCodecCtx->width*pCodecCtx->height;\cf10 \
\cf8 //            fwrite(pFrameYUV->data[0],1,y_size,fp_yuv);    //Y\cf10 \
\cf8 //            fwrite(pFrameYUV->data[1],1,y_size/4,fp_yuv);  //U\cf10 \
\cf8 //            fwrite(pFrameYUV->data[2],1,y_size/4,fp_yuv);  //V\cf10 \
\cf8 //\cf10 \
\cf8 //            printf("Flush Decoder: Succeed to decode 1 frame!\\n");\cf10 \
\cf8 //        \}\cf10 \
\cf8 //\cf10 \
\cf8 //    sws_freeContext(img_convert_ctx);\cf10 \
\cf8 //\cf10 \
\cf8 //    fclose(fp_yuv);\cf10 \
\cf8 //\cf10 \
\cf8 //     av_frame_free(&pFrameYUV);\cf10 \
\cf8 //     av_frame_free(&pFrame);\cf10 \
\cf8 //     avcodec_close(pCodecCtx);\cf10 \
\cf8 //     avformat_close_input(&pFormatCtx);\cf10 \
\cf8 //    return 0;\cf10 \
\cf8 //\}\cf10 \
}